<!DOCTYPE html>
<html>
<meta charset="UTF-8"/>
<style>
.row {
  display: flex;
}

.column {
  flex: 33.33%;
  padding: 5px;
}
p {
    font-size: 19px;
    margin-left: 19px;
}

</style>
<body>
<center><h1> Trabalho de Redes II - Canhão UDP</h1></center>

<center><h2> Autores: Gustavo Silveira Frehse & Thomas Bianchi Todt </h2></center>
<center>
<!-- <img src="tux.gif" style="width:100px;height:100px;"> -->
</center>
<p>O objetivo do Canhão UDP é examinar se há perda de pacote UDP/IP na nossa rede, e qual é a taxa aproximada desta perda. Além disso, será verificado também se as mensagens são entregues fora de ordem</p>
<p>Para tal, separamos em partes a implementação e análise dos dados:</p>
<ul>
    <li><a href="#implementacao"> Implementação </a></li>
    <li><a href="#analise"> Análise dos dados </a></li>
</ul>

<center><h2 id=implementacao > Implementação</h2></center>
<!-- <center><img src="computer.gif" style="width:107px;height:35px;"></center> -->
<h3> Cliente </h3>
    <p>O cliente é baseado no cliente normal UDP disponibilizado como exemplo no site da disciplina.</p>
    <p>Cada mensagem contém seu número de sequência, a fim de analisar a ocorrência de perda de sequência.</p>
    <p>O cliente não espera confirmação de recebimento pelo servidor, simplesmente continuando o envio de mensagens.</p>
    <p>Esse envio constante de mensagens é de onde deriva o nome do projeto: <b>CANHÃO UDP</b></p>
<h3> Servidor </h3>
    <p>O servidor também é baseado no modelo disponibilizado no site da disciplina.</p>
    <p>Dada a natureza do projeto, foi necessário definir a forma como o servidor detectaria o final do envio de mensagens pelo cliente.</p>
    <p>Com essa intenção, definimos um timeout para o recebimento de mensagens, de forma que se 2 segundos se passam sem o recebimento de uma nova mensagem, o programa se encaminha para o encerramento</p>
    <p>Ao receber uma mensagem do cliente, o servidor define a mensagem que ele espera na sequência (o número da recebida acrescido de 1).</p>
    <p>Caso a mensagem recebida a seguir contenha um número diferente do esperado, o servidor então identifica o acontecimento de perda de ordem</p>
    <p>Dessa forma, é considerado que em uma sequência como: "1 4 8 5 6 7 9", a ordem é perdida apenas uma vez (do 5 para o 8)</p>

<center><h2 id=analise > Análise dos dados </h3></center>
<center><img src="dog.gif" style="width:120px;height:104px;"></center>

<center><h3>Dados do projeto em C</h3></center>
<center>
<div class="row">
    <div class="column">
      <img src="dados/c_plot1000.png" alt="1000" style="width:40%">
    </div>
</div> 
</center>

<p>Para 1000 mensagens o servidor conseguiu suportar a tarefa, todas mensagens chegaram de acordo.</p>

<div class="row">
    <div class="column">
      <img src="dados/c_plot10000.png" alt="1000" style="width:90%">
    </div>
    <div class="column">
        <img src="dados/c_plot100000.png" alt="1000" style="width:90%">
    </div>
    <div class="column">
        <img src="dados/c_plot1000000.png" alt="1000" style="width:90%">
    </div>
</div> 
<p>
    Entretanto conforme o número de mensagens sobe, o número de erros cresce, mas não parece haver um padrão tão óbvio, 
    pois algumas vezes todas mensagens são entregues enquanto em outros momentos temos erros em testes consecutivos. 
    Parece haver algum misto de preempção do sistema operacional junto com o buffer do UDP, causando esse comportamento errático.
</p>
<p>
    Esse padrão de falta de padrão se repete ainda no maior teste feito, aquele com um milhão de mensagens. 
        Um dos testes perdeu metade das mensagens, enquanto outros foram feitos sem quase nenhum erro.
    </p>

    <p>

<h4>O projeto está todo disponível em <a href="https://www.github.com/tikaradate/udp_cannon">github</a></h4>

</html>
